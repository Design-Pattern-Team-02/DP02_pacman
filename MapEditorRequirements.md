# Pacman Map Editor - 요구사항 명세서

## 📋 프로젝트 개요

### 목적
Pacman 게임의 커스텀 맵을 생성할 수 있는 **독립적인 맵 에디터 도구** 개발

### 중요 포인트
⚠️ **이 프로젝트는 설계패턴 수업의 과제입니다.**
- **디자인 패턴의 적절한 적용이 평가의 핵심 요소입니다**
- 각 패턴이 왜 필요한지, 어떻게 문제를 해결하는지 명확히 설명 가능해야 함
- 패턴의 올바른 구현과 확장 가능성을 고려해야 함
- **⭐ 구현 완료 시 어떤 디자인 패턴을 어디에 적용했는지 반드시 명시해주세요**

### 범위
- **포함**: 새로운 맵 생성 및 저장 기능
- **제외**: 기존 맵 로드/수정 기능 (독립적 모듈로 개발)
- **향후 추가 예정**: Undo/Redo 기능

---

## 🎯 기능 요구사항

### 1. UI 구성

#### 1.1 전체 레이아웃
```
┌──────────────────────────────────────────────────────┐
│  [상단] 엔티티 팔레트                                   │
├──────────────────────────────────┬───────────────────┤
│                                  │                   │
│  [중앙] 맵 에디터 그리드           │  [오른쪽]          │
│  (56 × 63 셀)                    │  필수 엔티티       │
│                                  │  카운터            │
│                                  │                   │
│                                  │  [저장 버튼]       │
│                                  │  [초기화 버튼]     │
└──────────────────────────────────┴───────────────────┘
```

#### 1.2 상단 엔티티 팔레트
클릭 가능한 버튼 형태로 배치:

**필수 엔티티:**
1. **팩맨 (P)** - 플레이어 시작 위치
2. **Blinky (b)** - 빨강 유령 스폰
3. **Pinky (p)** - 분홍 유령 스폰
4. **Inky (i)** - 파랑 유령 스폰
5. **Clyde (c)** - 주황 유령 스폰

**자유 배치 엔티티:**
6. **벽 (x)** - 일반 벽
7. **GhostHouse 벽 (-)** - 유령 전용 통과 가능 벽
8. **SuperPacGum (o)** - 파워업 아이템

**도구:**
9. **지우개** - 엔티티 삭제
10. **X (취소)** - 현재 선택 해제

#### 1.3 오른쪽 카운터 패널
```
필수 엔티티 현황:
━━━━━━━━━━━━━━━
팩맨 (P):     0/1 ⚠️
Blinky (b):  0/1 ⚠️
Pinky (p):   0/1 ⚠️
Inky (i):    0/1 ⚠️
Clyde (c):   0/1 ⚠️
━━━━━━━━━━━━━━━

[💾 저장] (비활성)
[🗑️ 초기화]
```

#### 1.4 중앙 맵 에디터 그리드
- **크기**: 56 columns × 63 rows (고정)
- **셀 크기**: 8 × 8 픽셀
- **총 크기**: 448 × 504 픽셀
- **그리드 라인**: 항상 표시 (회색 선)

---

### 2. 사용자 인터랙션 플로우

#### 2.1 엔티티 배치 프로세스
```
1. 사용자가 상단 팔레트에서 엔티티 클릭
   ↓
2. 선택된 엔티티가 반투명 상태로 마우스를 따라다님
   ↓
3. 마우스가 그리드 위를 이동
   ├─ 🟢 초록색 하이라이트: 배치 가능
   └─ 🔴 빨간색 하이라이트: 이미 엔티티 존재 (겹침)
   ↓
4. 클릭 시
   ├─ 초록색 영역: 엔티티 배치 성공
   └─ 빨간색 영역: 배치 실패 (무시)
```

#### 2.2 시각적 피드백
- **반투명 엔티티**: AlphaComposite 0.5f 적용
- **배치 가능 (초록색)**: `Color(0, 255, 0, 100)`
- **배치 불가 (빨간색)**: `Color(255, 0, 0, 100)`
- **선택 해제 (X)**: 마우스 따라다니는 엔티티 제거

#### 2.3 배치 규칙
- **한 칸씩 클릭**: 드래그 배치 미지원
- **겹침 방지**: 동일 셀에 중복 배치 불가
- **필수 엔티티 개수 제한**:
  - 팩맨: 정확히 1개
  - 각 유령: 정확히 1개씩 (총 4개)

---

### 3. 자동 채우기 시스템

#### 3.1 PacGum 자동 배치
- **실행 시점**: 저장 버튼 클릭 시
- **대상**: 모든 빈 공간 (`' '`)
- **제외 대상**:
  - 벽 (x)
  - GhostHouse 벽 (-)
  - 팩맨 (P)
  - 유령 스폰 (b, p, i, c)
  - SuperPacGum (o)

#### 3.2 알고리즘 요구사항
- 모든 빈 공간(`null` 또는 `' '`)을 PacGum(`.`)으로 채우기
- 이중 루프로 전체 그리드 순회

---

### 4. 맵 검증 시스템

#### 4.1 저장 조건
**필수 조건 (모두 충족 시 저장 가능):**
1. 팩맨 (P): 정확히 1개
2. Blinky (b): 정확히 1개
3. Pinky (p): 정확히 1개
4. Inky (i): 정확히 1개
5. Clyde (c): 정확히 1개

**선택 조건 (권장):**
- GhostHouse 벽 (-): 최소 1개 이상 (유령이 집에서 출입하기 위함)

#### 4.2 검증 실패 시 동작
- **에러 메시지 팝업** (JOptionPane)
- 부족한 엔티티 목록 표시
- 예시:
  ```
  ❌ 맵 저장 실패

  다음 필수 엔티티가 부족합니다:
  - 팩맨 (P): 0/1
  - Pinky (p): 0/1

  모든 필수 엔티티를 배치해주세요.
  ```

---

### 5. 파일 저장

#### 5.1 저장 경로
- **폴더**: `src/resources/level/`
- **파일명**: 자동 생성 (예: `custom_map_001.csv`, `custom_map_002.csv`)
- **형식**: CSV (세미콜론 구분자)

#### 5.2 CSV 형식
```
x;x;x;x;x;x;...
x; ;.; ; ;.;...
x; ;P; ; ; ;...
...
```

#### 5.3 저장 프로세스
```
1. 검증 통과 확인
   ↓
2. 빈 공간에 PacGum (.) 자동 채우기
   ↓
3. CSV 파일 생성
   ↓
4. 성공 메시지 팝업
```

---

### 6. 초기화 기능
- **버튼**: 휴지통 아이콘 (🗑️)
- **동작**:
  - 확인 다이얼로그 표시
  - "정말 초기화하시겠습니까?"
  - 확인 시 → 모든 셀을 빈 공간으로 초기화
  - 취소 시 → 아무 동작 없음

---

## 🏗️ 디자인 패턴 적용 (핵심 평가 요소)

### 패턴 적용 가이드라인
이 프로젝트에서 고려해야 할 주요 디자인 패턴들입니다. 각 패턴이 해결하는 문제를 이해하고, 적절히 적용해주세요.

**⭐ 중요: 구현 완료 시 어떤 패턴을 어떻게 적용했는지 반드시 문서화해주세요.**

---

### 권장 패턴 목록

#### 1. **State Pattern** - 에디터 상태 관리
**해결할 문제:**
- 사용자가 선택한 엔티티에 따라 마우스 이벤트 처리 로직이 달라짐
- 선택 없음 / 배치 대기 / 삭제 모드 등 여러 상태가 존재
- if-else 분기문으로 처리하면 복잡도 증가 및 유지보수 어려움

**적용 시 고려사항:**
- 각 상태별로 독립적인 클래스 구현
- 상태 전환 로직 명확히 정의
- Open-Closed Principle 준수

---

#### 2. **Command Pattern** - 액션 캡슐화
**해결할 문제:**
- 사용자의 배치/삭제 액션을 되돌릴 수 있어야 함 (향후 Undo/Redo 기능)
- 각 액션의 실행과 취소 로직을 관리해야 함

**적용 시 고려사항:**
- execute()와 undo() 메서드 인터페이스 정의
- 커맨드 히스토리 스택 관리
- 매크로 기능 확장 가능성

---

#### 3. **Observer Pattern** - UI 동기화
**해결할 문제:**
- 맵 데이터 변경 시 여러 UI 컴포넌트가 동시에 업데이트되어야 함
  - 그리드 패널 (재렌더링)
  - 카운터 패널 (엔티티 개수 업데이트)
  - 저장 버튼 (활성화/비활성화)
- 강한 결합 시 유지보수 어려움

**적용 시 고려사항:**
- Subject와 Observer 인터페이스 정의
- 프로젝트 기존 Observer 패턴과 일관성 유지
- 느슨한 결합 (Loose Coupling) 구현

---

#### 4. **Singleton Pattern** - 에디터 매니저
**해결할 문제:**
- 에디터 전역 상태 (현재 맵, 선택된 타일, 검증 상태 등)를 여러 컴포넌트에서 접근
- 하나의 인스턴스만 존재해야 함

**적용 시 고려사항:**
- 프로젝트 기존 Singleton 패턴과 일관성 (ScoreManager, DifficultyManager)
- Thread-safety는 필요시 고려

---

#### 5. **Strategy Pattern** - 자동 채우기 알고리즘 (선택)
**해결할 문제:**
- 향후 다양한 자동 채우기 방식 지원 가능성
  - 전체 채우기 (현재)
  - 연결된 영역만 채우기 (Flood Fill)
  - 패턴 기반 채우기

**적용 시 고려사항:**
- 알고리즘 교체 용이성
- 런타임 전략 변경 가능성
- Open-Closed Principle 준수

---

#### 6. **Factory Pattern** - 엔티티 생성 (선택)
**해결할 문제:**
- 다양한 엔티티 타입 생성 로직 중앙화
- 프로젝트의 GhostFactory 패턴과 일관성 유지

**적용 시 고려사항:**
- 생성 로직 캡슐화
- 프로젝트 기존 Factory 패턴과 일관성

---

## 📦 클래스 설계 가이드

### 핵심 컴포넌트 구조
구현 시 다음과 같은 컴포넌트 구조를 고려하세요. 디자인 패턴을 적용하여 설계해주세요.

#### 데이터 레이어
- 맵 데이터 관리 클래스
- 엔티티 타입 정의 (Enum 등)

#### 상태 관리 (State Pattern 적용)
- 에디터 상태 인터페이스 및 구현체들
- 상태 관리자

#### 액션 처리 (Command Pattern 적용)
- 커맨드 인터페이스 및 구현체들
- 커맨드 매니저 (Undo/Redo 스택)

#### UI 레이어 (Observer Pattern 적용)
- 메인 프레임
- 엔티티 팔레트 패널
- 그리드 에디터 패널
- 카운터 패널
- 컨트롤 패널

#### 유틸리티
- CSV 파일 입출력
- 맵 검증 로직
- 자동 채우기 (Strategy Pattern 선택 적용)

#### 전역 관리 (Singleton Pattern 적용)
- 에디터 매니저

---

## 🚀 구현 권장 순서

### Phase 1: 기본 구조 (패턴 적용)
1. 데이터 모델 + Observer Pattern
2. 에디터 상태 관리 + State Pattern
3. UI 레이아웃 기본 구조
4. 그리드 렌더링

### Phase 2: 인터랙션
5. 엔티티 팔레트
6. 마우스 이벤트 처리
7. 반투명 미리보기 + 색상 피드백

### Phase 3: 저장 기능
8. 맵 검증 로직
9. CSV 파일 저장
10. PacGum 자동 채우기

### Phase 4: Command Pattern (Undo/Redo 대비)
11. 커맨드 인터페이스 및 구현
12. 커맨드 매니저

### Phase 5: 완성도
13. 초기화 기능
14. 에러 핸들링
15. UI 폴리싱

---

## 🎨 UI/UX 세부사항

### 그리드 렌더링
- 회색 그리드 라인 항상 표시
- 가로/세로 선으로 56×63 셀 구분
- 셀 크기: 8×8 픽셀

### 반투명 렌더링
- AlphaComposite를 사용하여 0.5f 투명도 적용
- 마우스 위치에 선택된 엔티티 이미지 표시

### 색상 피드백
- 배치 가능: `Color(0, 255, 0, 100)` 초록색
- 배치 불가: `Color(255, 0, 0, 100)` 빨간색
- 현재 마우스 그리드 셀에 색상 표시

---

## ✅ 테스트 요구사항

### 기능 테스트
- 맵 검증 로직 (필수 엔티티 개수 체크)
- 자동 채우기 정확성
- 커맨드 패턴 동작 (Undo/Redo 스택)

### 통합 테스트
- 엔티티 배치 시 UI 자동 업데이트 (Observer Pattern)
- CSV 파일 저장 및 형식 검증
- 검증 실패 시 에러 처리

### 실사용 테스트
- 생성한 맵을 게임에서 실제로 로드하여 플레이 가능 여부 확인

---

## 📚 참고사항

### GhostHouse 벽의 특수성
- **일반 벽 (x)**: 모든 엔티티 통과 불가
- **GhostHouse 벽 (-)**: 유령만 조건부 통과 가능
  - `WallCollisionDetector.checkWallCollision(entity, dx, dy, ignoreGhostHouses)`
  - 유령이 집에서 나오거나 돌아갈 때 통과
  - 팩맨은 통과 불가

### CSV 파일 형식
- 구분자: 세미콜론 (`;`)
- 크기: 56 columns × 63 rows
- 기존 `CsvReader` 참고하여 `CsvWriter` 구현

### 프로젝트 연동
- 중앙 제어 시스템(레벨 관리)과의 연동은 향후 고려
- 현재는 독립 실행 모드로 구현
- 파일 네이밍 컨벤션: `custom_map_XXX.csv`

---

## 🎓 평가 기준 (예상)

### 디자인 패턴 적용 (60%)
- ⭐ **패턴 적용 명시**: 어떤 패턴을 어디에 어떻게 적용했는지 명확히 문서화
- ⭐ State Pattern 구현 및 활용도
- ⭐ Command Pattern 구현 (Undo/Redo 대비)
- ⭐ Observer Pattern 구현 및 UI 동기화
- Singleton Pattern 적절성
- 추가 패턴 활용도 (Strategy, Factory 등)

### 기능 완성도 (30%)
- 필수 기능 구현 여부
- UI/UX 완성도
- 버그 없는 안정적인 동작

### 코드 품질 (10%)
- 가독성
- 주석 및 문서화
- 확장 가능성

---

## 🔗 관련 문서
- `DesignDocumentation.md` - 프로젝트 설계 문서
- `JustificationPatterns.md` - 디자인 패턴 정당성

---

추가로 기존 코드 변경은 최소화했으면 좋겠어. 